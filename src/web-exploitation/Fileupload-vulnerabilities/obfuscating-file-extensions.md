# File Uploads: Obfuscating file extentions

## Introduction

In today's web landscape, file upload features are essential for many applications, from profile picture uploads to document submissions. However, this functionality often comes with significant security risks. Developers typically implement various defenses to prevent malicious file uploads, yet these measures can sometimes be circumvented. One such method involves obfuscating file extensions to bypass security checks and upload a web shell, enabling remote code execution on the server. Understanding these techniques and how to defend against them is crucial for maintaining secure web applications.


## Table of Contents

- [File Uploads: Unrestricted File Uploads!](#file-uploads-unrestricted-file-uploads)
  - [Introduction](#Introduction)
  - [Table of Contents](#table-of-contents)
  - [How to identify](#how-to-identify)
  - [Code/tools/websites](#codetoolswebsites)
    - [Tools](#tools)
    - [Websites](#websites)
  - [Sample problem](#sample-problem)
    - [Problem Statement](#problem-statement)
    - [Solution](#solution)
  - [References](#references)
  - [Conclusion](#conclusion)


## How to identify

 Even the most exhaustive blacklists can potentially be bypassed using classic obfuscation techniques. Let's say the validation code is case sensitive and fails to recognize that exploit.pHp is in fact a .php file. If the code that subsequently maps the file extension to a MIME type is not case sensitive, this discrepancy allows you to sneak malicious PHP files past validation that may eventually be executed by the server. 

**Upload Section** :
Any type of upload can possibly have a upload vulnerability. Make sure you remember this when you encounter a upload section in real life.



## Code/tools/websites

### Tools
- **Burp Suite:** A web vulnerability scanner with tools for manual testing.

### Websites
> https://portswigger.net/web-security/file-upload
> https://ctf.hackthebox.com/ 


## Sample problem

### Problem Statement
This lab contains a vulnerable image upload function. Certain file extensions are blacklisted, but this defense can be bypassed using a classic obfuscation technique. 

- [Link to the Problem](https://portswigger.net/web-security/file-upload/lab-file-upload-web-shell-upload-via-obfuscated-file-extension)

### Solution
Here we have a upload section under My Accounts tab to upload the Avatar.
We use burpsuite proxy here to interupt the Requests. 

- **Initial Request for JPG**:
The Content-Type response header may provide clues as to what kind of file the server thinks it has served. If this header hasn't been explicitly set by the application code, it normally contains the result of the file extension/MIME type mapping. 
  ```
  Content-Disposition: form-data; name="avatar"; filename="filename.jpg"
  Content-Type: image/jpeg
  ``` 

- **Restriction with Blacklisting**:
This time when we try to upload this exploit directly...
  ```php
   <?php echo file_get_contents('/home/carlos/secret'); ?>
  ```
   We are not able to do so...

- **The difference**:
   Here we just change the filename header to "exploit.php%00.png". This %00 is called the null symbol and this strips the .png extension after the upload
   ```
  Content-Disposition: form-data; name="avatar"; filename="exploit.php%00.png"
  ``` 
- **done**:
Now just use GET in the repeater in burpsuite to get the flag!!


## References

- [PortSwigger Web Security Academy](https://portswigger.net/web-security/file-upload)


## Conclusion
In this section, we learnt how to bypass file type validation using the null symbol.